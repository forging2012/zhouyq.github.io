
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>SA-Logs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="zhouyq">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="SA-Logs">
<meta property="og:url" content="http://salogs.com/index.html">
<meta property="og:site_name" content="SA-Logs">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SA-Logs">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="SA-Logs" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="SA-Logs" title="SA-Logs"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SA-Logs">SA-Logs</a></h1>
				<h2 class="blog-motto">拥抱开源，分享经验!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/history">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:salogs.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/20/configure-salt/" title="配置 salt" itemprop="url">配置 salt</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-20T09:31:26.000Z" itemprop="datePublished"> 发表于 2015-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="配置">配置</h1><h2 id="客户端配置">客户端配置</h2><p>客户端配置比较简单，只需要配置一下server的地址就可以了，复杂的配置等到以后遇到的适合在进行介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置salt服务端地址</span></span><br><span class="line">vi /etc/salt/minion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里也可以写主机名</span></span><br><span class="line">master: <span class="number">192.168</span>.<span class="number">1.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完成后重启服务</span></span><br><span class="line">service salt-minion restart</span><br></pre></td></tr></table></figure>
<h2 id="服务端操作">服务端操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些client发起了验证请求 </span></span><br><span class="line">salt-key list</span><br><span class="line"></span><br><span class="line">Accepted Keys:</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:  <span class="comment"># 这里列出了为被接受的client 主机名</span></span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Rejected Keys:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受所有验证请求</span></span><br><span class="line">salt-key -A</span><br><span class="line">The following keys are going to be accepted:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Proceed? [n/Y] Y</span><br><span class="line">Key <span class="keyword">for</span> minion host01 accepted.</span><br><span class="line">Key <span class="keyword">for</span> minion host02 accepted.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再查看一下</span></span><br><span class="line">salt-key list</span><br><span class="line">Accepted Keys:  <span class="comment"># 已经接受</span></span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">Rejected Keys:</span><br></pre></td></tr></table></figure>
<h1 id="简单验证执行命令">简单验证执行命令</h1><h2 id="远程执行命令">远程执行命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">salt aws-bj* cmd.run uptime</span><br><span class="line">host01:</span><br><span class="line">     <span class="number">09</span>:<span class="number">42</span>:<span class="number">13</span> up  <span class="number">2</span>:<span class="number">02</span>,  <span class="number">2</span> users,  load average: <span class="number">0.05</span>, <span class="number">0.03</span>, <span class="number">0.05</span></span><br><span class="line">host02:</span><br><span class="line">     <span class="number">09</span>:<span class="number">42</span>:<span class="number">12</span> up  <span class="number">1</span>:<span class="number">28</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br></pre></td></tr></table></figure>
<h1 id="下篇预告">下篇预告</h1><ul>
<li><a href="http://salogs.com/news/2015/08/20/group-salt/">03. 将client主机分组</a></li>
</ul>
<h1 id="系列文章">系列文章</h1><ul>
<li><a href="http://salogs.com/news/2015/08/20/ubuntu-install-salt/">01. Ubuntu 安装salt</a></li>
<li><a href="http://salogs.com/news/2015/08/20/configure-salt/">02. 配置 salt</a></li>
<li><a href="http://salogs.com/news/2015/08/20/group-salt/">03. 将client主机分组</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/运维自动化/">运维自动化</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/salt/">salt</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/20/ubuntu-install-salt/" title="Ubuntu 安装salt" itemprop="url">Ubuntu 安装salt</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-20T09:10:26.000Z" itemprop="datePublished"> 发表于 2015-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="添加仓库">添加仓库</h1><p>最新的salt包会发布在 Ubuntu saltstack PPA。如果你的系统中有<code>add-apt-repository</code> 工具，可以通过一条命令添加仓库并导入PPA key：</p>
<h2 id="通过add-apt-repository添加仓库及PPA_key">通过add-apt-repository添加仓库及PPA key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:saltstack/salt</span><br><span class="line"></span><br><span class="line"> Salt, the remote execution and configuration management tool.</span><br><span class="line"> More info: https://launchpad.net/~saltstack/+archive/ubuntu/salt</span><br><span class="line">Press [ENTER] to <span class="built_in">continue</span> or ctrl-c to cancel adding it</span><br><span class="line"></span><br><span class="line">gpg: keyring `/tmp/tmpys0ah_nb/secring.gpg<span class="string">' created</span><br><span class="line">gpg: keyring `/tmp/tmpys0ah_nb/pubring.gpg'</span> created</span><br><span class="line">gpg: requesting key <span class="number">0</span>E27C0A6 from hkp server keyserver.ubuntu.com</span><br><span class="line">gpg: /tmp/tmpys0ah_nb/trustdb.gpg: trustdb created</span><br><span class="line">gpg: key <span class="number">0</span>E27C0A6: public key <span class="string">"Launchpad PPA for Salt Stack"</span> imported</span><br><span class="line">gpg: Total number processed: <span class="number">1</span></span><br><span class="line">gpg:               imported: <span class="number">1</span>  (RSA: <span class="number">1</span>)</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有找到add-apt-repository命令可以执行下面的命令进行安装</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-software-properties</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>可能也需要安装下面的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="手动添加仓库及PPA_key">手动添加仓库及PPA  key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> deb http://ppa.launchpad.net/saltstack/salt/ubuntu `lsb_release -sc` main | sudo tee /etc/apt/sources.list.d/saltstack.list</span><br><span class="line">wget -q -O- <span class="string">"http://keyserver.ubuntu.com:11371/pks/lookup?op=get&amp;search=0x4759FA960E27C0A6"</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<h2 id="更新仓库元数据">更新仓库元数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h1 id="安装包">安装包</h1><h2 id="服务端">服务端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install salt-master salt-minion salt-syndic</span><br></pre></td></tr></table></figure>
<h2 id="客户端">客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install salt-master salt-minion</span><br></pre></td></tr></table></figure>
<h1 id="ZEROMQ_4">ZEROMQ 4</h1><p>ZeroMQ 4 在 Ubuntu 14.04 以上版本已经与系统集成。因此Ubuntu 12.04 LTS 之前的版本需要升级到ZEROMQ 4</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/运维自动化/">运维自动化</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/salt/">salt</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/20/iptables-save/" title="保存iptable规则并开机自动加载" itemprop="url">保存iptable规则并开机自动加载</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-20T08:46:27.000Z" itemprop="datePublished"> 发表于 2015-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="iptables-save">iptables-save</h1><p>利用iptables-save命令可以将iptable规则保存到一个持久化存储的目录中，不同的系统保存的目录也有所不同（IPv4）：</p>
<p>Debian/Ubuntu: <code>iptables-save</code> &gt; /etc/iptables/rules.v4</p>
<p>RHEL/CentOS: <code>iptables-save</code> &gt; /etc/sysconfig/iptables</p>
<p>保存之后，可以通过iptables-restore命令载入（IPv4）：</p>
<p>Debian/Ubuntu: <code>iptables-restore</code> &lt; /etc/iptables/rules.v4</p>
<p>RHEL/CentOS: <code>iptables-restore</code> &lt; /etc/sysconfig/iptables</p>
<p>上面是针对IPv5的规则，如果你有使用IPv6的规则，通常需要执行下面对应的IPv6保存和恢复的命令（IPv4：</p>
<p>Debian/Ubuntu: <code>ip6tables-save</code> &gt; /etc/iptables/rules.v6<br>RHEL/CentOS: <code>ip6tables-save</code> &gt; /etc/sysconfig/ip6tables</p>
<p><strong>注意：</strong> 这种方式只是保存规则和恢复的一种方式，并不是说保存规则后下次启动就会自动加载。一定要记住这点，如果要想系统启动后自动加载请看下面的方式。</p>
<h1 id="iptables-persistent_(Debian/Ubuntu)">iptables-persistent (Debian/Ubuntu)</h1><p>从 Ubuntu 10.04 LTS (Lucid) 和 Debian 6.0 (Squeeze) 版本开始，可以通过安装一个名为 “iptables-persistent” 的包，安装后它以守护进程的方式来运行，系统重启后可以自动将保存的内容加载到iptables中。当然前提也是需要先保存规则。</p>
<h2 id="安装">安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install iptables-persistent</span><br></pre></td></tr></table></figure>
<h2 id="保存规则">保存规则</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service  iptables-persistent save</span><br><span class="line">* Saving rules...                                                                                                                                                                 *  IPv4...                                                                                                                                                                        *  IPv6...</span><br><span class="line"></span><br><span class="line">ls -<span class="number">1</span> /etc/iptables/</span><br><span class="line">rules.v4</span><br><span class="line">rules.v6</span><br><span class="line"></span><br><span class="line">cat  /etc/iptables/rules.v4</span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Thu Aug 20 08:59:52 2015</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [<span class="number">5726</span>:<span class="number">774869</span>]</span><br><span class="line">:FORWARD ACCEPT [<span class="number">170</span>:<span class="number">27598</span>]</span><br><span class="line">:OUTPUT ACCEPT [<span class="number">5467</span>:<span class="number">789045</span>]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Thu Aug 20 08:59:52 2015</span></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Thu Aug 20 08:59:52 2015</span></span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [<span class="number">23</span>:<span class="number">1596</span>]</span><br><span class="line">:INPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">:OUTPUT ACCEPT [<span class="number">9</span>:<span class="number">540</span>]</span><br><span class="line">:POSTROUTING ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">-A POSTROUTING <span class="operator">-s</span> <span class="number">10.0</span>.<span class="number">0.0</span>/<span class="number">16</span> -o eth0 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Thu Aug 20 08:59:52 2015</span></span><br></pre></td></tr></table></figure>
<h1 id="RHEL_和_CentOS_保存规则">RHEL 和 CentOS 保存规则</h1><p>RHEL/CentOS 提供了简单的方式来持久化存储iptables规则，可以直接通过iptables服务的命令来完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list | grep iptables</span><br><span class="line">  iptables       	<span class="number">0</span>:off	<span class="number">1</span>:off	<span class="number">2</span>:on	<span class="number">3</span>:on	<span class="number">4</span>:on	<span class="number">5</span>:on	<span class="number">6</span>:off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不是开机启动，需要执行下面命令</span></span><br><span class="line">chkconfig iptables on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
<p>IPv4规则信息会保存到 /etc/sysconfig/iptables 文件中，IPv6 规则保存到 /etc/sysconfig/ip6tables 文件中。 必须执行<code>service iptables save</code> 命令才会保存，保存后系统重启后会自动加载。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/经验分享/">经验分享</a>►<a class="article-category-link" href="/categories/经验分享/Iptables/">Iptables</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iptables/">iptables</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/17/database-backup-and-recovery/" title="MySQL备份与恢复" itemprop="url">MySQL备份与恢复</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T06:04:14.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="数据库备份与恢复">数据库备份与恢复</h1><h2 id="当前数据库结构">当前数据库结构</h2><p>db01 （主）</p>
<p>db02 （从）</p>
<h2 id="备份策略">备份策略</h2><ul>
<li>每天一次全量备份</li>
<li>每小时一次增量备份</li>
<li>通过热备工具（不锁表，不影响线上应用）备份主库数据</li>
<li>备份数据保存到db01，备份完成scp到db02</li>
<li>保留一个月的增量及全量备份</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>备份类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>00:01</td>
<td>全量备份</td>
</tr>
<tr>
<td>01:01</td>
<td>增量备份(当天首次)</td>
</tr>
<tr>
<td>02:01~23:01</td>
<td>增量备份</td>
</tr>
</tbody>
</table>
<blockquote>
<p>随着数据量的增加，全量备份可以做成每周一次，每2~8小时一次增量备份</p>
</blockquote>
<h2 id="备份目录">备份目录</h2><p>db{01,02}:/data/backup/{full,incremental}/</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backup/</span><br><span class="line">├── full</span><br><span class="line">│   ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>       <span class="comment"># 每日全量备份</span></span><br><span class="line">│   └── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>.log   <span class="comment"># 全量备份日志</span></span><br><span class="line">└── incremental </span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_14        <span class="comment"># 每小时增量备份</span></span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_14.log    <span class="comment"># 每小时增量备份日志</span></span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_15</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_15.log</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_16</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_16.log</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_17</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_17.log</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_18</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_18.log</span><br><span class="line">    ├── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_19</span><br><span class="line">    └── <span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_19.log</span><br></pre></td></tr></table></figure>
<h2 id="备份计划任务">备份计划任务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Info   : 数据库备份</span></span><br><span class="line"><span class="comment"># Author : zhouyq</span></span><br><span class="line"><span class="comment"># CTime  : 2015-08-16</span></span><br><span class="line"><span class="comment"># 全量备份</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> * * *     /bin/bash /root/bin/bakdb.sh full</span><br><span class="line"><span class="comment"># 第一次增量备份</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> * * *     /bin/bash /root/bin/bakdb.sh incremental first</span><br><span class="line"><span class="comment"># 其他时间段增量备份</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>-<span class="number">23</span> * * *  /bin/bash /root/bin/bakdb.sh incremental</span><br></pre></td></tr></table></figure>
<h2 id="备份脚本">备份脚本</h2><p>/root/bin/bakdb.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">fullPath=<span class="string">"/data/backup/full"</span></span><br><span class="line">incrPath=<span class="string">"/data/backup/incremental"</span></span><br><span class="line">bakdate=`date +<span class="string">'%F'</span>`</span><br><span class="line">bakhour=`date +<span class="string">'%H'</span>`</span><br><span class="line"></span><br><span class="line">oneHourAgo=`date <span class="operator">-d</span> <span class="string">'1 hours ago'</span> +<span class="string">'%F_%H'</span>`</span><br><span class="line"></span><br><span class="line">BakB<span class="keyword">in</span>=<span class="string">"/usr/bin/innobackupex --no-timestamp --user=root --socket /data/db/tmp/mysql.sock  --defaults-file=/usr/local/mysql/my.cnf --sleep 100"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># backup function</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hotbackup</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  baktype=<span class="variable">$1</span></span><br><span class="line">  logfile=<span class="variable">$2</span></span><br><span class="line">  incrpath=<span class="variable">$3</span></span><br><span class="line">  bakpath=<span class="variable">$4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$baktype</span>"</span> == <span class="string">"full"</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="variable">$BakBin</span>  <span class="variable">$bakpath</span>   &gt; <span class="variable">$logfile</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">  <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$baktype</span>"</span> == <span class="string">"incremental"</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="variable">$BakBin</span> --incremental <span class="variable">$incrpath</span> --incremental-basedir <span class="variable">$bakpath</span> &gt; <span class="variable">$logfile</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============= Main =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"full"</span> ];<span class="keyword">then</span></span><br><span class="line">   <span class="comment"># 全量备份</span></span><br><span class="line">   hotbackup <span class="string">"full"</span> <span class="string">"<span class="variable">$&#123;fullPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>.log"</span> <span class="string">"none"</span> <span class="string">"<span class="variable">$fullPath</span>/<span class="variable">$bakdate</span>"</span></span><br><span class="line">   /usr/bin/scp -P <span class="number">9922</span> -rp  <span class="variable">$&#123;fullPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>* db02:<span class="variable">$&#123;fullPath&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"incremental"</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 判断是否为第一次增量备份，只有第一次增量备份目录指向全量备份</span></span><br><span class="line">  <span class="comment"># 第二次开始增量备份的上一次目录指向第一次增量目录即可</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$2</span>"</span> == <span class="string">"first"</span> ];<span class="keyword">then</span></span><br><span class="line">     hotbackup <span class="string">"incremental"</span> <span class="string">"<span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>.log"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>"</span> <span class="string">"<span class="variable">$fullPath</span>/<span class="variable">$bakdate</span>"</span></span><br><span class="line">     /usr/bin/scp -P <span class="number">9922</span> -rp <span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>* db02:<span class="variable">$&#123;incrPath&#125;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     hotbackup <span class="string">"incremental"</span> <span class="string">"<span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>.log"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;oneHourAgo&#125;</span>"</span></span><br><span class="line">     /usr/bin/scp -P <span class="number">9922</span> -rp <span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>* db02:<span class="variable">$&#123;incrPath&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="恢复">恢复</h2><h3 id="全量备份恢复">全量备份恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --user=root --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --apply-log /data/backup/full/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span></span><br><span class="line"></span><br><span class="line">innobackupex --user=root --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --move-back /data/backup/full/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span></span><br></pre></td></tr></table></figure>
<h3 id="增量备份恢复">增量备份恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span> </span><br><span class="line">  </span><br><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span> --incremental-dir=/data/backup/incremental/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_14  </span><br><span class="line">  </span><br><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span> --incremental-dir=/data/backup/incremental/<span class="number">2015</span>-<span class="number">08</span>-<span class="number">16</span>_15</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/经验分享/">经验分享</a>►<a class="article-category-link" href="/categories/经验分享/MySQL/">MySQL</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/XtraBackup/">XtraBackup</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/04/ten-go-best-practice/" title="【转】十条有用的 GO 技术" itemprop="url">【转】十条有用的 GO 技术</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-04T01:16:16.000Z" itemprop="datePublished"> 发表于 2015-08-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文<a href="http://mikespook.com/2014/07/%e5%8d%81%e6%9d%a1%e6%9c%89%e7%94%a8%e7%9a%84-go-%e6%8a%80%e6%9c%af/" target="_blank" rel="external">在此</a>，实用总结。</p>
<hr>
<h1 id="十条有用的_Go_技术">十条有用的 Go 技术</h1><p>这里是我过去几年中编写的大量 Go 代码的经验总结而来的自己的最佳实践。我相信它们具有弹性的。这里的弹性是指：<br>某个应用需要适配一个灵活的环境。你不希望每过 3 到 4 个月就不得不将它们全部重构一遍。添加新的特性应当很容易。许多人参与开发该应用，它应当可以被理解，且维护简单。许多人使用该应用，bug 应该容易被发现并且可以快速的修复。我用了很长的时间学到了这些事情。其中的一些很微小，但对于许多事情都会有影响。所有这些都仅仅是建议，具体情况具体对待，并且如果有帮助的话务必告诉我。随时留言:)</p>
<h1 id="1-_使用单一的_GOPATH">1. 使用单一的 GOPATH</h1><p>多个 GOPATH 的情况并不具有弹性。GOPATH 本身就是高度自我完备的（通过导入路径）。有多个 GOPATH 会导致某些副作用，例如可能使用了给定的库的不同的版本。你可能在某个地方升级了它，但是其他地方却没有升级。而且，我还没遇到过任何一个需要使用多个 GOPATH 的情况。所以只使用单一的 GOPATH，这会提升你 Go 的开发进度。</p>
<p>许多人不同意这一观点，接下来我会做一些澄清。像 <a href="https://github.com/coreos/etcd" target="_blank" rel="external">etcd</a> 或 <a href="https://camlistore.org/" target="_blank" rel="external">camlistore</a> 这样的大项目使用了像 <a href="https://github.com/tools/godep" target="_blank" rel="external">godep</a> 这样的工具，将所有依赖保存到某个目录中。也就是说，这些项目自身有一个单一的 GOPATH。它们只能在这个目录里找到对应的版本。除非你的项目很大并且极为重要，否则不要为每个项目使用不同的 GOPATH。如果你认为项目需要一个自己的 GOPATH 目录，那么就创建它，否则不要尝试使用多个 GOPATH。它只会拖慢你的进度。</p>
<h1 id="2-_将_for-select_封装到函数中">2. 将 for-select 封装到函数中</h1><p>如果在某个条件下，你需要从 for-select 中退出，就需要使用标签。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line"> </span><br><span class="line">L:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span> L</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">"ending"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，需要联合break使用标签。这有其用途，不过我不喜欢。这个例子中的 for 循环看起来很小，但是通常它们会更大，而判断break的条件也更为冗长。</p>
<p>如果需要退出循环，我会将 for-select 封装到函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    foo()</span><br><span class="line">    fmt.Println(<span class="string">"ending"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> foo() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以返回一个错误（或任何其他值），也是同样漂亮的，只需要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 阻塞</span><br><span class="line"><span class="keyword">if</span> err := foo(); err != nil &#123;</span><br><span class="line">    // 处理 err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-_在初始化结构体时使用带有标签的语法">3. 在初始化结构体时使用带有标签的语法</h1><p>这是一个无标签语法的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Foo <span class="typename">string</span></span><br><span class="line">    Bar <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    t := T&#123;<span class="string">"example"</span>, <span class="number">123</span>&#125; <span class="comment">// 无标签语法</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果你添加一个新的字段到T结构体，代码会编译失败：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Foo <span class="typename">string</span></span><br><span class="line">    Bar <span class="typename">int</span></span><br><span class="line">    Qux <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    t := T&#123;<span class="string">"example"</span>, <span class="number">123</span>&#125; <span class="comment">// 无法编译</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用了标签语法，Go 的兼容性规则（<a href="http://golang.org/doc/go1compat" target="_blank" rel="external">http://golang.org/doc/go1compat</a>）会处理代码。例如在向net包的类型添加叫做Zone的字段，参见：<a href="http://golang.org/doc/go1.1#library" target="_blank" rel="external">http://golang.org/doc/go1.1#library</a>。回到我们的例子，使用标签语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> T struct &#123;</span><br><span class="line">    Foo string</span><br><span class="line">    Bar int</span><br><span class="line">    Qux string</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    t := T&#123;Foo: <span class="string">"example"</span>, Qux: <span class="number">123</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个编译起来没问题，而且弹性也好。不论你如何添加其他字段到T结构体。你的代码总是能编译，并且在以后的 Go 的版本也可以保证这一点。只要在代码集中执行go vet，就可以发现所有的无标签的语法。</p>
<h1 id="4-_将结构体的初始化拆分到多行">4. 将结构体的初始化拆分到多行</h1><p>如果有两个以上的字段，那么就用多行。它会让你的代码更加容易阅读，也就是说不要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T&#123;Foo: <span class="string">"example"</span>, Bar:someLongVariable, Qux:anotherLongVariable, B: forgetToAddThisToo&#125;</span><br></pre></td></tr></table></figure>
<p>而是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T&#123;</span><br><span class="line">    Foo: <span class="string">"example"</span>,</span><br><span class="line">    Bar: someLongVariable,</span><br><span class="line">    Qux: anotherLongVariable,</span><br><span class="line">    B: forgetToAddThisToo,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有许多好处，首先它容易阅读，其次它使得允许或屏蔽字段初始化变得容易（只要注释或删除它们），最后添加其他字段也更容易（只要添加一行）。</p>
<h1 id="5-_为整数常量添加_String()_方法">5. 为整数常量添加 String() 方法</h1><p>如果你利用 iota 来使用自定义的整数枚举类型，务必要为其添加 String() 方法。例如，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="typename">int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Running State = <span class="constant">iota</span></span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果你创建了这个类型的一个变量，然后输出，会得到一个整数（<a href="http://play.golang.org/p/V5VVFB05HB" target="_blank" rel="external">http://play.golang.org/p/V5VVFB05HB</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    state := Running</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print: "state 0"</span></span><br><span class="line">    fmt.Println(<span class="string">"state "</span>, state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非你回顾常量定义，否则这里的0看起来毫无意义。只需要为State类型添加String()方法就可以修复这个问题（<a href="http://play.golang.org/p/ewMKl6K302" target="_blank" rel="external">http://play.golang.org/p/ewMKl6K302</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (s State) String() <span class="typename">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> s &#123;</span><br><span class="line">    <span class="keyword">case</span> Running:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Running"</span></span><br><span class="line">    <span class="keyword">case</span> Stopped:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stopped"</span></span><br><span class="line">    <span class="keyword">case</span> Rebooting:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rebooting"</span></span><br><span class="line">    <span class="keyword">case</span> Terminated:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Terminated"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的输出是：state: Running。显然现在看起来可读性好了很多。在你调试程序的时候，这会带来更多的便利。同时还可以在实现 MarshalJSON()、UnmarshalJSON() 这类方法的时候使用同样的手段。</p>
<h1 id="6-_让_iota_从_a_+1_开始增量">6. 让 iota 从 a +1 开始增量</h1><p>在前面的例子中同时也产生了一个我已经遇到过许多次的 bug。假设你有一个新的结构体，有一个State字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="typename">string</span></span><br><span class="line">    Port  <span class="typename">int</span></span><br><span class="line">    State State</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果基于 T 创建一个新的变量，然后输出，你会得到奇怪的结果（<a href="http://play.golang.org/p/LPG2RF3y39" target="_blank" rel="external">http://play.golang.org/p/LPG2RF3y39</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    t := T&#123;Name: <span class="string">"example"</span>, Port: <span class="number">6666</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// prints: "t &#123;Name:example Port:6666 State:Running&#125;"</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 bug 了吗？State字段没有初始化，Go 默认使用对应类型的零值进行填充。由于State是一个整数，零值也就是0，但在我们的例子中它表示Running。</p>
<p>那么如何知道 State 被初始化了？还是它真得是在Running模式？没有办法区分它们，那么这就会产生未知的、不可预测的 bug。不过，修复这个很容易，只要让 iota 从 +1 开始（<a href="http://play.golang.org/p/VyAq-3OItv" target="_blank" rel="external">http://play.golang.org/p/VyAq-3OItv</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Running State = <span class="constant">iota</span> + <span class="number">1</span></span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在t变量将默认输出Unknown，不是吗？ :) </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    t := T&#123;Name: <span class="string">"example"</span>, Port: <span class="number">6666</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出： "t &#123;Name:example Port:6666 State:Unknown&#125;"</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过让 iota 从零值开始也是一种解决办法。例如，你可以引入一个新的状态叫做Unknown，将其修改为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown State = <span class="constant">iota</span></span><br><span class="line">    Running</span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="7-_返回函数调用">7. 返回函数调用</h1><p>我已经看过很多代码例如（<a href="http://play.golang.org/p/8Rz1EJwFTZ" target="_blank" rel="external">http://play.golang.org/p/8Rz1EJwFTZ</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> bar() (<span class="typename">string</span>, error) &#123;</span><br><span class="line">    v, err := foo()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> v, <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，你只需要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> bar() (<span class="typename">string</span>, error) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单也更容易阅读（当然，除非你要对某些内部的值做一些记录）。</p>
<h1 id="8-_把_slice、map_等定义为自定义类型">8. 把 slice、map 等定义为自定义类型</h1><p>将 slice 或 map 定义成自定义类型可以让代码维护起来更加容易。假设有一个Server类型和一个返回服务器列表的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> ListServers() []Server &#123;</span><br><span class="line">    <span class="keyword">return</span> []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设需要获取某些特定名字的服务器。需要对 ListServers() 做一些改动，增加筛选条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListServers 返回服务器列表。只会返回包含 name 的服务器。空的 name 将会返回所有服务器。</span></span><br><span class="line"><span class="keyword">func</span> ListServers(name <span class="typename">string</span>) []Server &#123;</span><br><span class="line">    servers := []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回所有服务器</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servers</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回过滤后的结果</span></span><br><span class="line">    filtered := <span class="built_in">make</span>([]Server, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, server := <span class="keyword">range</span> servers &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(server.Name, name) &#123;</span><br><span class="line">            filtered = <span class="built_in">append</span>(filtered, server)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以用这个来筛选有字符串Foo的服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    servers := ListServers(<span class="string">"Foo"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出：“servers [&#123;Name:Foo1&#125; &#123;Name:Foo2&#125;]”</span></span><br><span class="line">    fmt.Printf(<span class="string">"servers %+v\n"</span>, servers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然这个函数能够正常工作。不过它的弹性并不好。如果你想对服务器集合引入其他逻辑的话会如何呢？例如检查所有服务器的状态，为每个服务器创建一个数据库记录，用其他字段进行筛选等等……</p>
<p>现在引入一个叫做Servers的新类型，并且修改原始版本的 ListServers() 返回这个新类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers []Server</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ListServers 返回服务器列表</span></span><br><span class="line"><span class="keyword">func</span> ListServers() Servers &#123;</span><br><span class="line">    <span class="keyword">return</span> []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要做的是只要为Servers类型添加一个新的Filter()方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Filter 返回包含 name 的服务器。空的 name 将会返回所有服务器。</span></span><br><span class="line"><span class="keyword">func</span> (s Servers) Filter(name <span class="typename">string</span>) Servers &#123;</span><br><span class="line">    filtered := <span class="built_in">make</span>(Servers, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, server := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(server.Name, name) &#123;</span><br><span class="line">            filtered = <span class="built_in">append</span>(filtered, server)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以针对字符串Foo筛选服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">    servers := ListServers()</span><br><span class="line">    servers = servers.Filter(<span class="string">"Foo"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"servers %+v\n"</span>, servers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈！看到你的代码是多么的简单了吗？还想对服务器的状态进行检查？或者为每个服务器添加一条数据库记录？没问题，添加以下新方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> (s Servers) Check()</span><br><span class="line"><span class="keyword">func</span> (s Servers) AddRecord()</span><br><span class="line"><span class="keyword">func</span> (s Servers) Len()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="9-_withContext_封装函数">9. withContext 封装函数</h1><p>有时对于函数会有一些重复劳动，例如锁/解锁，初始化一个新的局部上下文，准备初始化变量等等……这里有一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> foo() &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// foo 相关的工作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> bar() &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// bar 相关的工作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> qux() &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// qux 相关的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想要修改某个内容，你需要对所有的都进行修改。如果它是一个常见的任务，那么最好创建一个叫做withContext的函数。这个函数的输入参数是另一个函数，并用调用者提供的上下文来调用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> withLockContext(fn <span class="keyword">func</span>()) &#123;</span><br><span class="line">    mu.Lock</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要将之前的函数用这个进行封装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> foo() &#123;</span><br><span class="line">    withLockContext(<span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="comment">// foo 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> bar() &#123;</span><br><span class="line">    withLockContext(<span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="comment">// bar 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> qux() &#123;</span><br><span class="line">    withLockContext(<span class="keyword">func</span>() &#123;</span><br><span class="line">        <span class="comment">// qux 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要光想着加锁的情形。对此来说最好的用例是数据库链接。现在对 withContext 函数作一些小小的改动：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> withDBContext(fn <span class="keyword">func</span>(db DB) error) error &#123;</span><br><span class="line">    <span class="comment">// 从连接池获取一个数据库连接</span></span><br><span class="line">    dbConn := NewDB()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> fn(dbConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，它获取一个连接，然后传递给提供的参数，并且在调用函数的时候返回错误。你需要做的只是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">func</span> foo() &#123;</span><br><span class="line">    withDBContext(<span class="keyword">func</span>(db *DB) error &#123;</span><br><span class="line">        <span class="comment">// foo 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> bar() &#123;</span><br><span class="line">    withDBContext(<span class="keyword">func</span>(db *DB) error &#123;</span><br><span class="line">        <span class="comment">// bar 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">func</span> qux() &#123;</span><br><span class="line">    withDBContext(<span class="keyword">func</span>(db *DB) error &#123;</span><br><span class="line">        <span class="comment">// qux 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你在考虑一个不同的场景，例如作一些预初始化？没问题，只需要将它们加到withDBContext就可以了。这对于测试也同样有效。</p>
<p>这个方法有个缺陷，它增加了缩进并且更难阅读。再次提示，永远寻找最简单的解决方案。</p>
<h1 id="10-_为访问_map_增加_setter，getters">10. 为访问 map 增加 setter，getters</h1><p>如果你重度使用 map 读写数据，那么就为其添加 getter 和 setter 吧。通过 getter 和 setter 你可以将逻辑封分别装到函数里。这里最常见的错误就是并发访问。如果你在某个 goroutein 里有这样的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m[<span class="string">"foo"</span>] = bar</span><br></pre></td></tr></table></figure>
<p>还有这个：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">"foo"</span>)</span><br></pre></td></tr></table></figure>
<p>会发生什么？你们中的大多数应当已经非常熟悉这样的竞态了。简单来说这个竞态是由于 map 默认并非线程安全。不过你可以用互斥量来保护它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line">m[<span class="string">"foo"</span>] = <span class="string">"bar"</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"foo"</span>)</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>假设你在其他地方也使用这个 map。你必须把互斥量放得到处都是！然而通过 getter 和 setter 函数就可以很容易的避免这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> Put(key, value <span class="typename">string</span>) &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    m[key] = value</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> Delete(key <span class="typename">string</span>) &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(m, key)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用接口可以对这一过程做进一步的改进。你可以将实现完全隐藏起来。只使用一个简单的、设计良好的接口，然后让包的用户使用它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">    Delete(key <span class="typename">string</span>)</span><br><span class="line">    Get(key <span class="typename">string</span>) <span class="typename">string</span></span><br><span class="line">    Put(key, value <span class="typename">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是个例子，不过你应该能体会到。对于底层的实现使用什么都没关系。不光是使用接口本身很简单，而且还解决了暴露内部数据结构带来的大量的问题。</p>
<p>但是得承认，有时只是为了同时对若干个变量加锁就使用接口会有些过分。理解你的程序，并且在你需要的时候使用这些改进。</p>
<h1 id="总结">总结</h1><p>抽象永远都不是容易的事情。有时，最简单的就是你已经实现的方法。要知道，不要让你的代码看起来很聪明。Go 天生就是个简单的语言，在大多数情况下只会有一种方法来作某事。简单是力量的源泉，也是为什么在人的层面它表现的如此有弹性。</p>
<p>如果必要的话，使用这些基数。例如将[]Server转化为Servers是另一种抽象，仅在你有一个合理的理由的情况下这么做。不过有一些技术，如 iota 从 1 开始计数总是有用的。再次提醒，永远保持简单。</p>
<p>特别感谢 Cihangir Savas、Andrew Gerrand、Ben Johnson 和 Damian Gryski 提供的极具价值的反馈和建议。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/经验分享/">经验分享</a>►<a class="article-category-link" href="/categories/经验分享/Go/">Go</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Go/">Go</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/02/aliyun-vpc-snat-md/" title="阿里云VPC网络无EIP的主机上网问题" itemprop="url">阿里云VPC网络无EIP的主机上网问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-02T13:38:58.000Z" itemprop="datePublished"> 发表于 2015-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="问题由来">问题由来</h1><p>阿里云的VPC与其他基于OpenStack的IaaS不同，他的路由只是作为多网段的路由交换，不提供内到外的路由，因此在VPC内的主机除非绑定EIP，否则是无法连接公网的。通过工单询问客服，得到的结论是通过在路由器上添加一个路由，通过一个绑定EIP的主机做NAT上网，通过设置iptables的方式来实现。</p>
<h1 id="VPC结构图">VPC结构图</h1><p><img src="/img/aliyun-vpc-snat.jpg" alt=""></p>
<h1 id="虚拟路由器配置">虚拟路由器配置</h1><h2 id="添加路由">添加路由</h2><p>为了让内网服务器借助EIP访问公网，所以设置所有目标地址0.0.0.0/0下一跳都转发到绑定了公网IP的ECS实例上。这里的下一跳ECS不支持搜索，需要提前记号名称：</p>
<p><img src="/img/aliyun-vpc-snat-2.jpg" alt=""></p>
<h1 id="绑定EIP的主机配置">绑定EIP的主机配置</h1><h2 id="iptables添加SNAT规则">iptables添加SNAT规则</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING <span class="operator">-s</span> <span class="number">192.168</span>.<span class="number">2.0</span>/<span class="number">24</span> -j SNAT --to-source <span class="number">192.168</span>.<span class="number">2.20</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> ubuntu 14.04 系统保存iptables设置需要安装iptables-persistent包，然后通过 <code>service iptables-persistent save</code> 的方式保存配置，安装完iptables-persistent后该服务随系统一起启动并会把保存的配置应用</p>
</blockquote>
<h2 id="开启IP转发">开启IP转发</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.ip_forward=1"</span> &gt;&gt;  /etc/sysctl.conf &amp;&amp; sysctl -p</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/经验分享/">经验分享</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IaaS/">IaaS</a><a href="/tags/route/">route</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/02/shell-array-demo/" title="shell 数组应用实例" itemprop="url">shell 数组应用实例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-02T10:01:37.000Z" itemprop="datePublished"> 发表于 2015-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="数组定义">数组定义</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个空数组</span></span><br><span class="line">Result=()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义并给数组赋值</span></span><br><span class="line">arr=(a b c d e)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>  </p>
<ul>
<li><p>默认数组中的元素是以空格分隔的，如果元素是包含空格的字符串，最好用双引号括起来</p>
</li>
<li><p>shell中的默认分隔符可以通过修改 $IFS变量来设置</p>
</li>
</ul>
</blockquote>
<h1 id="数组读取/删除">数组读取/删除</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span>  <span class="comment"># 结果: 5</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[*]&#125;</span>  <span class="comment"># 结果: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出所有数据</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span>  <span class="comment"># 结果: a b c d e</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span>  <span class="comment"># 结果: a b c d e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出第二个元素的数据</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span>  <span class="comment"># 结果: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line">filelist=(`ls`)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;filelist[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二个元素</span></span><br><span class="line"><span class="built_in">unset</span> arr[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span>  <span class="comment"># 结果: a c d e</span></span><br></pre></td></tr></table></figure>
<h1 id="切片/元素替换">切片/元素替换</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"></span><br><span class="line">arr2=(<span class="variable">$&#123;arr[@]:0:3&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr2[@]&#125;</span>  <span class="comment"># 结果 a b c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]/a/aaa&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>切片(分片):</strong> 直接通过 ${数组名[@或*]:起始位置:长度} 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</li>
</ul>
<ul>
<li><strong>替换:</strong> ${数组名[@或*]/查找字符/替换字符} 该操作不会改变原先数组内容，如果需要修改，请重新定义变量并赋值。</li>
</ul>
</blockquote>
<h1 id="实例">实例</h1><blockquote>
<p>在一个多域名的web server环境中，通过分析访问日志，统计最近8小时有用户访问的域名（去重），并显示。</p>
<p>日志格式：X-Forworld-IP User-IP YYYY-MM-DD HH:mm:ss method “URL” HTTP响应码 服务器处理时间 返回大小 “Refer” “浏览器信息” “虚拟主机域名” 真实处理请求的主机</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">AWKB<span class="keyword">in</span>=<span class="string">"/usr/bin/awk"</span></span><br><span class="line">EGREPB<span class="keyword">in</span>=<span class="string">"/bin/egrep"</span></span><br><span class="line">SORTB<span class="keyword">in</span>=<span class="string">"/usr/bin/sort"</span></span><br><span class="line">SEDB<span class="keyword">in</span>=<span class="string">"/bin/sed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟主机</span></span><br><span class="line">VSName=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间段</span></span><br><span class="line">TimePeriod=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤字符串</span></span><br><span class="line">FilterKeys=<span class="string">''</span><span class="string">'DNSPod-Monitor|JianKongBao'</span><span class="string">''</span></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line">LOGPath=<span class="string">"/logs/nginx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最终输出的数组变量</span></span><br><span class="line">Result=()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (( TimePeriod &gt; <span class="number">0</span> ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  LogTime=`date <span class="operator">-d</span> <span class="string">"- <span class="variable">$&#123;TimePeriod&#125;</span>hours"</span> +%Y-%m-%d-%H`</span><br><span class="line">  LogFile=<span class="variable">$&#123;VSName&#125;</span>_<span class="variable">$&#123;LogTime&#125;</span>.log</span><br><span class="line"></span><br><span class="line">  Result=(<span class="variable">$&#123;Result[@]&#125;</span> `<span class="variable">$AWKBin</span> <span class="string">'&#123;if($5!~/HEAD/ &amp;&amp; $5!~/\"\"/ ) print $0&#125;'</span> <span class="variable">$&#123;LOGPath&#125;</span>/<span class="variable">$&#123;LogFile&#125;</span> | \</span><br><span class="line">         <span class="variable">$EGREPBin</span> -v <span class="variable">$FilterKeys</span> | <span class="variable">$AWKBin</span> <span class="string">'&#123;print $NF&#125;'</span> | <span class="variable">$AWKBin</span> -F <span class="string">'@'</span> <span class="string">'&#123;print $1&#125;'</span> |\</span><br><span class="line">         <span class="variable">$SORTBin</span> -u`)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第<span class="variable">$TimePeriod</span> 个日志:<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ((TimePeriod--))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"未去重：<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">Result=($(awk -vRS=<span class="string">' '</span> <span class="string">'!a[$1]++'</span> &lt;&lt;&lt; <span class="variable">$&#123;Result[@]&#125;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"去重以后:<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>►<a class="article-category-link" href="/categories/linux/script/">script</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/array/">array</a><a href="/tags/script/">script</a><a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/news/2015/08/02/migration-to-github/" title="salogs正式迁移到github" itemprop="url">salogs正式迁移到github</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="zhouyq" target="_blank" itemprop="author">zhouyq</a>
		
  <p class="article-time">
    <time datetime="2015-08-01T16:00:00.000Z" itemprop="datePublished"> 发表于 2015-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>由于之前的blog内容过于陈旧，很多文档现在来看会给广大朋友带来困扰，因此决定将之前的所有内容都抛弃，从今天开始重新写！</p>
<p>最近5年由于工作原因也没有顾得上更新blog，近期会有一系列文档更新，都是这五年来的一些工作经验。</p>
<p>由于大家共识的原因，本blog于2015-08-02正式迁移到<a href="https://github.com/zhouyq/zhouyq.github.io" target="_blank" rel="external">GitHub</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/其他/">其他</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/经验分享/Go/" title="Go">Go<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/经验分享/Iptables/" title="Iptables">Iptables<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/经验分享/MySQL/" title="MySQL">MySQL<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/script/" title="script">script<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/经验分享/" title="经验分享">经验分享<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/运维自动化/" title="运维自动化">运维自动化<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/salt/" title="salt">salt<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/route/" title="route">route<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/IaaS/" title="IaaS">IaaS<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/iptables/" title="iptables">iptables<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/XtraBackup/" title="XtraBackup">XtraBackup<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Go/" title="Go">Go<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/script/" title="script">script<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/array/" title="array">array<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/其他/" title="其他">其他<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://goodrain.com" target="_blank" title="会给你带来惊喜的云平台">好雨云平台</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> The future is ours! <br/>
			La La La...</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/https://github.com/zhouyq" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:zyq916@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="zhouyq">zhouyq</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
